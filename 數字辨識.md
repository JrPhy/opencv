åœ¨å½±åƒè¾¨è­˜ä¸­ï¼Œæ•¸å­—è¾¨è­˜æ˜¯ä¸€å€‹ç›¸å°ç°¡å–®çš„å°ˆæ¡ˆï¼Œå› ç‚ºè®ŠåŒ–å°‘ä¸”æµç¨‹å–®ç´”ï¼Œæ˜¯ä¸€å€‹å¾ˆå¥½å­¸ç¿’çš„å°ˆæ¡ˆã€‚

## ä¸€ã€å‰è™•ç†
å‰è™•ç†é€šå¸¸åŒ…å«ä»¥ä¸‹æ­¥é©Ÿ
1. äºŒå€¼åŒ–
2. é™å™ª
3. æ‰¾é‚Š
4. æ‰¾è¼ªå»“\
3a. å½¢æ…‹å­¸é‹ç®—(è†¨è„¹/ä¾µè•)
æ‰¾å®Œå¾Œå°±å¯ä»¥å»æŠŠæ¯å€‹æ•¸å­—åˆ†å‰²å‡ºä¾†ã€‚åšæ•¸å­—åˆ†é™¤äº†è¦èƒ½æ‰¾å‡ºä¾†ï¼Œé‚„è¦èƒ½æ­£ç¢ºåœ°åˆ†å‰²æ•¸å­—ï¼Œä¾‹å¦‚ 101 å°±è¦åˆ†å‡º 101 è€Œä¸æ˜¯ 1, 0, 1ã€‚
```c++
#include <opencv2/opencv.hpp>
#include <iostream>
using namespace cv;
using namespace std;

int main() {
    // 1. è®€å–ç°éšåœ–ç‰‡
    Mat img = imread("digits.png", IMREAD_GRAYSCALE);
    if (img.empty()) {
        cout << "ç„¡æ³•è®€å–åœ–ç‰‡" << endl;
        return -1;
    }
    imshow("åŸå§‹å½±åƒ", img);
    // 2. é™å™ª (Gaussian Blur)
    Mat blurred;
    GaussianBlur(img, blurred, Size(5,5), 0);

    // 3. ä½¿ç”¨ Canny é‚Šç·£æª¢æ¸¬
    Mat edges;
    Canny(blurred, edges, 50, 150);

    // 4. ä½¿ç”¨é–‰é‹ç®— (Closing)
    Mat kernel = getStructuringElement(MORPH_RECT, Size(5,5));
    Mat morphed;
    morphologyEx(edges, morphed, MORPH_CLOSE, kernel, Point(-1,-1), 2);
    imshow("é–‰é‹ç®—çµæœ", morphed);

    // 5. æ‰¾è¼ªå»“
    vector<vector<Point>> contours;
    vector<Vec4i> hierarchy;
    findContours(morphed, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

    // 6. ç¹ªè£½åˆ†å‰²çµæœ
    Mat output_canvas;
    cvtColor(img, output_canvas, COLOR_GRAY2BGR);

    cout << "--- åˆ†å‰²èˆ‡åˆä½µçµæœå±•ç¤º ---" << endl;
    for (size_t idx = 0, i = 0; idx < contours.size(); idx++, i++;) {
        Rect rect = boundingRect(contours[idx]);
        // åœ¨åŸåœ–ä¸Šç•«å‡ºç´…è‰²æ¡†æ¡†
        rectangle(output_canvas, rect, Scalar(0,0,255), 2);
        // å¯«ä¸Šåºè™Ÿ
        putText(output_canvas, "#" + to_string(i), Point(rect.x, rect.y - 5),
                FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0,0,255), 1);
        // æ“·å– ROI
        Mat roi = img(rect);
        cout << "æ•¸å­—å€å¡Š #" << (i+1) << ":" << endl;
        string winName = "ROI " + to_string(i+1);
        imshow(winName, roi);
    }

    cout << "\næ•´å¼µåœ–çš„æ¨™è¨˜çµæœ:" << endl;
    imshow("åˆ†å‰²çµæœ", output_canvas);

    waitKey(0); // ç­‰å¾…æŒ‰éµå¾Œé—œé–‰è¦–çª—
    return 0;
}
```
![img](img/digits.png)
![img](img/digits_mark.png)

## äºŒã€è¾¨è­˜
ä¸€èˆ¬ä¾†èªªæœƒéœ€è¦ä¸€å€‹å·²ç¶“é è¨“ç·´å¥½çš„æ¨¡å‹ä¾†åšè¾¨è­˜ï¼Œé€™é‚Šå°±ç”¨ tesseract-ocr ä¾†åš
```c++
#include <opencv2/opencv.hpp>
#include <tesseract/baseapi.h>
#include <leptonica/allheaders.h>
#include <iostream>
using namespace cv;
using namespace std;

int main() {
    // 1. è®€å–ç°éšåœ–ç‰‡
    Mat img = imread("digits.png", IMREAD_GRAYSCALE);
    if (img.empty()) {
        cout << "ç„¡æ³•è®€å–åœ–ç‰‡" << endl;
        return -1;
    }
    imshow("åŸå§‹å½±åƒ", img);

    // 2. é™å™ª (Gaussian Blur)
    Mat blurred;
    GaussianBlur(img, blurred, Size(5,5), 0);

    // 3. ä½¿ç”¨ Canny é‚Šç·£æª¢æ¸¬
    Mat edges;
    Canny(blurred, edges, 50, 150);

    // 4. é–‰é‹ç®— (Closing)
    Mat kernel = getStructuringElement(MORPH_RECT, Size(5,5));
    Mat morphed;
    morphologyEx(edges, morphed, MORPH_CLOSE, kernel, Point(-1,-1), 2);

    // 5. æ‰¾è¼ªå»“
    vector<vector<Point>> contours;
    vector<Vec4i> hierarchy;
    findContours(morphed, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

    // 6. å»ºç«‹å½©è‰²è¼¸å‡ºç•«å¸ƒ
    Mat output_canvas;
    cvtColor(img, output_canvas, COLOR_GRAY2BGR);

    // åˆå§‹åŒ– Tesseract
    tesseract::TessBaseAPI *ocr = new tesseract::TessBaseAPI();
    if (ocr->Init(NULL, "eng")) {
        cout << "Tesseract åˆå§‹åŒ–å¤±æ•—" << endl;
        return -1;
    }
    // è¨­å®šç™½åå–®
    ocr->SetVariable("tessedit_char_whitelist", "0123456789+-.");

    cout << "--- åˆ†å‰²èˆ‡åˆä½µçµæœå±•ç¤º ---" << endl;
    int i = 0;
    for (size_t idx = 0; idx < contours.size(); idx++, i++) {
        Rect rect = boundingRect(contours[idx]);
        Mat roi = img(rect);

        // åè½‰é¡è‰²
        Mat roi_inv;
        bitwise_not(roi, roi_inv);

        // æ”¾å¤§
        Mat roi_resized;
        resize(roi_inv, roi_resized, Size(), 2.0, 2.0, INTER_CUBIC);

        // è£œé‚Šæ¡†
        Mat roi_padded;
        copyMakeBorder(roi_resized, roi_padded, 20, 20, 20, 20, BORDER_CONSTANT, Scalar(255,255,255));

        // OCR è¾¨è­˜
        ocr->SetImage(roi_padded.data, roi_padded.cols, roi_padded.rows, 1, roi_padded.step);
        string text = string(ocr->GetUTF8Text());
        // å»é™¤ç©ºç™½èˆ‡æ›è¡Œ
        text.erase(remove(text.begin(), text.end(), '\n'), text.end());
        text.erase(remove(text.begin(), text.end(), '\r'), text.end());

        // ç¹ªè£½çµæœ
        rectangle(output_canvas, rect, Scalar(0,0,255), 2);
        putText(output_canvas, text, Point(rect.x, rect.y - 10),
                FONT_HERSHEY_SIMPLEX, 0.7, Scalar(0,0,255), 2);

        cout << "åºè™Ÿ #" << i << " [" << text << "]" << endl;
        string winName = "ROI " + to_string(i);
        imshow(winName, roi_padded);
    }

    cout << "\næ•´å¼µåœ–çš„æ¨™è¨˜çµæœ:" << endl;
    imshow("åˆ†å‰²çµæœ", output_canvas);

    waitKey(0);
    ocr->End();
    return 0;
}
```
![img](img/digits_identify.png)

## ä¸‰ã€è¾¨è­˜å¡è™Ÿ
ç¾åœ¨å¾ˆå¤šæ‰‹æ©Ÿæ”¯ä»˜å¯ä»¥ç¶ä¿¡ç”¨å¡ï¼Œè€Œåœ¨ç¶å®šæ™‚å¯ä»¥ç›´æ¥æ‹ç…§ä¾†å¹«ä½ è‡ªå‹•è¼¸å…¥å¡è™Ÿï¼Œç•¶ç„¶ä¸ä¸€å®šå…¨éƒ½èƒ½è¾¨è­˜å¾—å‡ºä¾†ï¼Œä½†å¤šæ•¸æ•¸å­—å¯ä»¥ï¼Œçœä¸‹äº†ä¸€äº›æ™‚é–“ã€‚
```C++#include <opencv2/opencv.hpp>
#include <tesseract/baseapi.h>
#include <iostream>
#include <vector>
#include <algorithm>
#include <sstream>

using namespace cv;
using namespace std;

// ç¸®æ”¾å½±åƒ
Mat resizeImage(const Mat& image, int width = 0, int height = 0) {
    if (width == 0 && height == 0) return image.clone();
    Size size;
    if (width > 0) {
        float r = width / (float)image.cols;
        size = Size(width, cvRound(image.rows * r));
    } else {
        float r = height / (float)image.rows;
        size = Size(cvRound(image.cols * r), height);
    }
    Mat resized;
    resize(image, resized, size, 0, 0, INTER_AREA);
    return resized;
}

int main() {
    bool debug = false; // ğŸ”§ Debug æ¨¡å¼é–‹é—œ

    // è®€å–å½±åƒ
    Mat image = imread("creditcard.png");
    if (image.empty()) {
        cout << "Image not found!" << endl;
        return -1;
    }

    // å»ºç«‹æ¨¡æ¿
    Mat ref;
    cvtColor(image, ref, COLOR_BGR2GRAY);
    threshold(ref, ref, 10, 255, THRESH_BINARY_INV);

    vector<vector<Point>> refCnts;
    findContours(ref.clone(), refCnts, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
    sort(refCnts.begin(), refCnts.end(),
         [](const vector<Point>& c1, const vector<Point>& c2) {
             return boundingRect(c1).x < boundingRect(c2).x;
         });

    vector<Mat> digits;
    for (auto& c : refCnts) {
        Rect roi = boundingRect(c);
        Mat digit = ref(roi);
        resize(digit, digit, Size(57, 88));
        digits.push_back(digit);
    }

    // é è™•ç†
    Mat gray = resizeImage(image, 300);
    cvtColor(gray, gray, COLOR_BGR2GRAY);

    Mat rectKernel = getStructuringElement(MORPH_RECT, Size(9, 3));
    Mat sqKernel   = getStructuringElement(MORPH_RECT, Size(5, 5));

    Mat tophat;
    morphologyEx(gray, tophat, MORPH_TOPHAT, rectKernel);

    Mat blurred;
    GaussianBlur(tophat, blurred, Size(5, 5), 0);

    Mat edged;
    Canny(blurred, edged, 10, 150);

    Mat gradX;
    morphologyEx(edged, gradX, MORPH_CLOSE, rectKernel);

    Mat thresh;
    threshold(gradX, thresh, 0, 255, THRESH_BINARY | THRESH_OTSU);
    morphologyEx(thresh, thresh, MORPH_CLOSE, sqKernel);

    vector<vector<Point>> cnts;
    findContours(thresh.clone(), cnts, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

    vector<Rect> locs;
    for (const auto& c : cnts) {
        Rect r = boundingRect(c);
        float ar = r.width / (float)r.height;
        if (ar > 2.5 && ar < 4.0 && r.width > 40 && r.width < 55 && r.height > 10 && r.height < 20) {
            locs.push_back(r);
        }
    }
    sort(locs.begin(), locs.end(),
         [](const Rect& a, const Rect& b) { return a.x < b.x; });

    // OCR åˆå§‹åŒ–
    tesseract::TessBaseAPI tess;
    tess.Init(NULL, "eng", tesseract::OEM_LSTM_ONLY);
    tess.SetVariable("tessedit_char_whitelist", "0123456789");
    tess.SetPageSegMode(tesseract::PSM_SINGLE_LINE);

    Mat kernel = Mat::ones(2, 2, CV_8U);
    vector<string> output;

    for (size_t i = 0; i < locs.size(); ++i) {
        Rect r = locs[i];
        Mat group = gray(Rect(max(0, r.x - 10), max(0, r.y - 10),
                              min(gray.cols - r.x, r.width + 20),
                              min(gray.rows - r.y, r.height + 20)));

        resize(group, group, Size(), 3, 3, INTER_CUBIC);
        threshold(group, group, 0, 255, THRESH_BINARY | THRESH_OTSU);

        if (countNonZero(group) < (group.rows * group.cols / 2)) {
            bitwise_not(group, group);
        }
        erode(group, group, kernel);

        if (debug) {
            imshow("Group " + to_string(i + 1), group);
            waitKey(0);
        }

        tess.SetImage(group.data, group.cols, group.rows, 1, group.step);
        string text = tess.GetUTF8Text();
        text.erase(remove_if(text.begin(), text.end(), ::isspace), text.end());

        rectangle(image, Point(r.x - 5, r.y - 5),
                  Point(r.x + r.width + 5, r.y + r.height + 5),
                  Scalar(0, 0, 255), 1);
        putText(image, text, Point(r.x, r.y - 15),
                FONT_HERSHEY_SIMPLEX, 0.65, Scalar(0, 0, 255), 2);

        output.push_back(text);
    }

    // è¼¸å‡ºçµæœ
    ostringstream oss;
    for (size_t i = 0; i < output.size(); ++i) {
        oss << output[i];
        if (i != output.size() - 1) oss << "-";
    }
    cout << "\næœ€çµ‚è¾¨è­˜çµæœ: " << oss.str() << endl;

    imshow("Result", image);
    waitKey(0);

    return 0;
}
```
![img](img/credit_card.png)
