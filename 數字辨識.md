在影像辨識中，數字辨識是一個相對簡單的專案，因為變化少且流程單純，是一個很好學習的專案。

## 一、前處理
前處理通常包含以下步驟
1. 二值化
2. 降噪
3. 找邊
4. 找輪廓\
3a. 形態學運算(膨脹/侵蝕)
找完後就可以去把每個數字分割出來。做數字分除了要能找出來，還要能正確地分割數字，例如 101 就要分出 101 而不是 1, 0, 1。
```c++
#include <opencv2/opencv.hpp>
#include <iostream>
using namespace cv;
using namespace std;

int main() {
    // 1. 讀取灰階圖片
    Mat img = imread("digits.png", IMREAD_GRAYSCALE);
    if (img.empty()) {
        cout << "無法讀取圖片" << endl;
        return -1;
    }
    imshow("原始影像", img);
    // 2. 降噪 (Gaussian Blur)
    Mat blurred;
    GaussianBlur(img, blurred, Size(5,5), 0);

    // 3. 使用 Canny 邊緣檢測
    Mat edges;
    Canny(blurred, edges, 50, 150);

    // 4. 使用閉運算 (Closing)
    Mat kernel = getStructuringElement(MORPH_RECT, Size(5,5));
    Mat morphed;
    morphologyEx(edges, morphed, MORPH_CLOSE, kernel, Point(-1,-1), 2);
    imshow("閉運算結果", morphed);

    // 5. 找輪廓
    vector<vector<Point>> contours;
    vector<Vec4i> hierarchy;
    findContours(morphed, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

    // 6. 繪製分割結果
    Mat output_canvas;
    cvtColor(img, output_canvas, COLOR_GRAY2BGR);

    cout << "--- 分割與合併結果展示 ---" << endl;
    for (size_t idx = 0, i = 0; idx < contours.size(); idx++, i++;) {
        Rect rect = boundingRect(contours[idx]);
        // 在原圖上畫出紅色框框
        rectangle(output_canvas, rect, Scalar(0,0,255), 2);
        // 寫上序號
        putText(output_canvas, "#" + to_string(i), Point(rect.x, rect.y - 5),
                FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0,0,255), 1);
        // 擷取 ROI
        Mat roi = img(rect);
        cout << "數字區塊 #" << (i+1) << ":" << endl;
        string winName = "ROI " + to_string(i+1);
        imshow(winName, roi);
    }

    cout << "\n整張圖的標記結果:" << endl;
    imshow("分割結果", output_canvas);

    waitKey(0); // 等待按鍵後關閉視窗
    return 0;
}
```
![img](img/digits.png)
![img](img/digits_mark.png)

## 二、辨識
一般來說會需要一個已經預訓練好的模型來做辨識，或是用 [CNN](https://github.com/JrPhy/MachineLearning/blob/master/Neural_Network/%E6%91%BA%E7%A9%8D%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AFCNN.md)，這邊就用 tesseract-ocr 來做
```c++
#include <opencv2/opencv.hpp>
#include <tesseract/baseapi.h>
#include <leptonica/allheaders.h>
#include <iostream>
using namespace cv;
using namespace std;

int main() {
    // 1. 讀取灰階圖片
    Mat img = imread("digits.png", IMREAD_GRAYSCALE);
    if (img.empty()) {
        cout << "無法讀取圖片" << endl;
        return -1;
    }
    imshow("原始影像", img);

    // 2. 降噪 (Gaussian Blur)
    Mat blurred;
    GaussianBlur(img, blurred, Size(5,5), 0);

    // 3. 使用 Canny 邊緣檢測
    Mat edges;
    Canny(blurred, edges, 50, 150);

    // 4. 閉運算 (Closing)
    Mat kernel = getStructuringElement(MORPH_RECT, Size(5,5));
    Mat morphed;
    morphologyEx(edges, morphed, MORPH_CLOSE, kernel, Point(-1,-1), 2);

    // 5. 找輪廓
    vector<vector<Point>> contours;
    vector<Vec4i> hierarchy;
    findContours(morphed, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

    // 6. 建立彩色輸出畫布
    Mat output_canvas;
    cvtColor(img, output_canvas, COLOR_GRAY2BGR);

    // 初始化 Tesseract
    tesseract::TessBaseAPI *ocr = new tesseract::TessBaseAPI();
    if (ocr->Init(NULL, "eng")) {
        cout << "Tesseract 初始化失敗" << endl;
        return -1;
    }
    // 設定白名單
    ocr->SetVariable("tessedit_char_whitelist", "0123456789+-.");

    cout << "--- 分割與合併結果展示 ---" << endl;
    int i = 0;
    for (size_t idx = 0; idx < contours.size(); idx++, i++) {
        Rect rect = boundingRect(contours[idx]);
        Mat roi = img(rect);

        // 反轉顏色
        Mat roi_inv;
        bitwise_not(roi, roi_inv);

        // 放大
        Mat roi_resized;
        resize(roi_inv, roi_resized, Size(), 2.0, 2.0, INTER_CUBIC);

        // 補邊框
        Mat roi_padded;
        copyMakeBorder(roi_resized, roi_padded, 20, 20, 20, 20, BORDER_CONSTANT, Scalar(255,255,255));

        // OCR 辨識
        ocr->SetImage(roi_padded.data, roi_padded.cols, roi_padded.rows, 1, roi_padded.step);
        string text = string(ocr->GetUTF8Text());
        // 去除空白與換行
        text.erase(remove(text.begin(), text.end(), '\n'), text.end());
        text.erase(remove(text.begin(), text.end(), '\r'), text.end());

        // 繪製結果
        rectangle(output_canvas, rect, Scalar(0,0,255), 2);
        putText(output_canvas, text, Point(rect.x, rect.y - 10),
                FONT_HERSHEY_SIMPLEX, 0.7, Scalar(0,0,255), 2);

        cout << "序號 #" << i << " [" << text << "]" << endl;
        string winName = "ROI " + to_string(i);
        imshow(winName, roi_padded);
    }

    cout << "\n整張圖的標記結果:" << endl;
    imshow("分割結果", output_canvas);

    waitKey(0);
    ocr->End();
    return 0;
}
```
![img](img/digits_identify.png)

## 三、辨識卡號
現在很多手機支付可以綁信用卡，而在綁定時可以直接拍照來幫你自動輸入卡號。針對此種字體單一的情況，可以給一張所有數字的圖片，分割後再去跟信用卡上的數字做 [CNN](https://github.com/JrPhy/MachineLearning/blob/master/Neural_Network/%E6%91%BA%E7%A9%8D%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AFCNN.md)，然後取分數最高的那個，可全都使用 OPENCV 來做。
```c++
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>

using namespace std;
using namespace cv;

// --- 工具函數：調整圖像大小 ---
Mat resize(Mat image, int width = -1, int height = -1) {
    int h = image.rows;
    int w = image.cols;
    Size dim;

    if (width == -1 && height == -1) return image;

    if (width == -1) {
        float r = (float)height / h;
        dim = Size((int)(w * r), height);
    } else {
        float r = (float)width / w;
        dim = Size(width, (int)(h * r));
    }

    Mat resized;
    cv::resize(image, resized, dim, 0, 0, INTER_AREA);
    return resized;
}

// --- 工具函數：輪廓排序 ---
void sort_contours(vector<vector<Point>>& cnts, string method, vector<Rect>& boundingBoxes) {
    boundingBoxes.clear();
    for (const auto& c : cnts) {
        boundingBoxes.push_back(boundingRect(c));
    }

    // 建立索引進行排序
    vector<int> idx(cnts.size());
    iota(idx.begin(), idx.end(), 0);

    bool reverse = (method == "right-to-left" || method == "bottom-to-top");
    int i = (method == "top-to-bottom" || method == "bottom-to-top") ? 1 : 0;

    sort(idx.begin(), idx.end(), [&](int a, int b) {
        if (i == 0) { // 按 X 座標
            return reverse ? boundingBoxes[a].x > boundingBoxes[b].x : boundingBoxes[a].x < boundingBoxes[b].x;
        } else { // 按 Y 座標
            return reverse ? boundingBoxes[a].y > boundingBoxes[b].y : boundingBoxes[a].y < boundingBoxes[b].y;
        }
    });

    // 根據排序後的索引重新排列
    vector<vector<Point>> sorted_cnts;
    vector<Rect> sorted_boxes;
    for (int j : idx) {
        sorted_cnts.push_back(cnts[j]);
        sorted_boxes.push_back(boundingBoxes[j]);
    }
    cnts = sorted_cnts;
    boundingBoxes = sorted_boxes;
}

int main() {
    // 1. 處理模板
    Mat img = imread("credit_card_01.png");
    if (img.empty()) return -1;

    Mat ref, ref_gray;
    cvtColor(img, ref_gray, COLOR_BGR2GRAY);
    threshold(ref_gray, ref, 10, 255, THRESH_BINARY_INV);

    vector<vector<Point>> refCnts;
    findContours(ref.clone(), refCnts, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

    vector<Rect> refBoxes;
    sort_contours(refCnts, "left-to-right", refBoxes);

    map<int, Mat> digits;
    for (int i = 0; i < refCnts.size(); i++) {
        Mat roi = ref(refBoxes[i]);
        cv::resize(roi, roi, Size(57, 88));
        digits[i] = roi;
    }

    // 2. 處理輸入圖像
    Mat image = imread("credit_card_01.png");
    image = resize(image, 300);
    Mat gray, tophat;
    cvtColor(image, gray, COLOR_BGR2GRAY);

    Mat rectKernel = getStructuringElement(MORPH_RECT, Size(9, 3));
    Mat sqKernel = getStructuringElement(MORPH_RECT, Size(5, 5));

    morphologyEx(gray, tophat, MORPH_TOPHAT, rectKernel);

    Mat gradX;
    Sobel(tophat, gradX, CV_32F, 1, 0, -1);
    gradX = abs(gradX);

    double minVal, maxVal;
    minMaxLoc(gradX, &minVal, &maxVal);
    gradX.convertTo(gradX, CV_8U, 255.0 / (maxVal - minVal), -minVal * 255.0 / (maxVal - minVal));

    morphologyEx(gradX, gradX, MORPH_CLOSE, rectKernel);
    Mat thresh;
    threshold(gradX, thresh, 0, 255, THRESH_BINARY | THRESH_OTSU);
    morphologyEx(thresh, thresh, MORPH_CLOSE, sqKernel);

    vector<vector<Point>> cnts;
    findContours(thresh.clone(), cnts, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

    vector<Rect> locs;
    for (const auto& c : cnts) {
        Rect r = boundingRect(c);
        float ar = (float)r.width / r.height;
        if (ar > 2.5 && ar < 4.0) {
            if (r.width > 40 && r.width < 55 && r.height > 10 && r.height < 20) {
                locs.push_back(r);
            }
        }
    }

    sort(locs.begin(), locs.end(), [](const Rect& a, const Rect& b) {
        return a.x < b.x;
    });

    string final_output = "";

    // 3. 遍歷組與辨識
    for (const auto& gRect : locs) {
        // 擴大一點區域提取每一組數字
        int gx = max(0, gRect.x - 5);
        int gy = max(0, gRect.y - 5);
        int gw = min(image.cols - gx, gRect.width + 10);
        int gh = min(image.rows - gy, gRect.height + 10);
        
        Mat group = gray(Rect(gx, gy, gw, gh));
        threshold(group, group, 0, 255, THRESH_BINARY | THRESH_OTSU);

        vector<vector<Point>> digitCnts;
        findContours(group.clone(), digitCnts, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
        vector<Rect> dBoxes;
        sort_contours(digitCnts, "left-to-right", dBoxes);

        for (const auto& dRect : dBoxes) {
            Mat roi = group(dRect);
            cv::resize(roi, roi, Size(57, 88));

            vector<double> scores;
            for (int i = 0; i < 10; i++) {
                Mat res;
                matchTemplate(roi, digits[i], res, TM_CCOEFF);
                double minV, maxV;
                minMaxLoc(res, &minV, &maxV);
                scores.push_back(maxV);
            }
            int prediction = distance(scores.begin(), max_element(scores.begin(), scores.end()));
            final_output += to_string(prediction);
        }
        rectangle(image, Rect(gx, gy, gw, gh), Scalar(0, 0, 255), 1);
        putText(image, final_output.substr(final_output.size()-4), Point(gRect.x, gRect.y - 15), 
                FONT_HERSHEY_SIMPLEX, 0.65, Scalar(0, 0, 255), 2);
    }

    cout << "Credit Card #: " << final_output << endl;
    imshow("Result", image);
    waitKey(0);

    return 0;
}
```
![img](img/ocr_a_reference.png)\
![img](img/credit_card.png)\
![img](img/credit_card_01.png)
