在影像辨識中，數字辨識是一個相對簡單的專案，因為變化少且流程單純，是一個很好學習的專案。

## 一、前處理
前處理通常包含以下步驟
1. 二值化
2. 降噪
3. 找邊
4. 找輪廓
3a. 形態學運算(膨脹/侵蝕)
找完後就可以去把每個數字分割出來
```c++
#include <opencv2/opencv.hpp>
#include <iostream>
using namespace cv;
using namespace std;

int main() {
    // 1. 讀取灰階圖片
    Mat img = imread("digits.png", IMREAD_GRAYSCALE);
    if (img.empty()) {
        cout << "無法讀取圖片" << endl;
        return -1;
    }
    imshow("原始影像", img);
    // 2. 降噪 (Gaussian Blur)
    Mat blurred;
    GaussianBlur(img, blurred, Size(5,5), 0);

    // 3. 使用 Canny 邊緣檢測
    Mat edges;
    Canny(blurred, edges, 50, 150);

    // 4. 使用閉運算 (Closing)
    Mat kernel = getStructuringElement(MORPH_RECT, Size(5,5));
    Mat morphed;
    morphologyEx(edges, morphed, MORPH_CLOSE, kernel, Point(-1,-1), 2);
    imshow("閉運算結果", morphed);

    // 5. 找輪廓
    vector<vector<Point>> contours;
    vector<Vec4i> hierarchy;
    findContours(morphed, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

    // 6. 繪製分割結果
    Mat output_canvas;
    cvtColor(img, output_canvas, COLOR_GRAY2BGR);

    cout << "--- 分割與合併結果展示 ---" << endl;
    for (size_t idx = 0, i = 0; idx < contours.size(); idx++, i++;) {
        Rect rect = boundingRect(contours[idx]);
        // 在原圖上畫出紅色框框
        rectangle(output_canvas, rect, Scalar(0,0,255), 2);
        // 寫上序號
        putText(output_canvas, "#" + to_string(i), Point(rect.x, rect.y - 5),
                FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0,0,255), 1);
        // 擷取 ROI
        Mat roi = img(rect);
        cout << "數字區塊 #" << (i+1) << ":" << endl;
        string winName = "ROI " + to_string(i+1);
        imshow(winName, roi);
    }

    cout << "\n整張圖的標記結果:" << endl;
    imshow("分割結果", output_canvas);

    waitKey(0); // 等待按鍵後關閉視窗
    return 0;
}
```
![img](img/digits.png)
![img](img/digits_mark.png)

## 二、辨識
一般來說會需要一個已經預訓練好的模型來做辨識，這邊就用 tesseract-ocr 來做
```c++
#include <opencv2/opencv.hpp>
#include <tesseract/baseapi.h>
#include <leptonica/allheaders.h>
#include <iostream>
using namespace cv;
using namespace std;

int main() {
    // 1. 讀取灰階圖片
    Mat img = imread("digits.png", IMREAD_GRAYSCALE);
    if (img.empty()) {
        cout << "無法讀取圖片" << endl;
        return -1;
    }
    imshow("原始影像", img);

    // 2. 降噪 (Gaussian Blur)
    Mat blurred;
    GaussianBlur(img, blurred, Size(5,5), 0);

    // 3. 使用 Canny 邊緣檢測
    Mat edges;
    Canny(blurred, edges, 50, 150);

    // 4. 閉運算 (Closing)
    Mat kernel = getStructuringElement(MORPH_RECT, Size(5,5));
    Mat morphed;
    morphologyEx(edges, morphed, MORPH_CLOSE, kernel, Point(-1,-1), 2);

    // 5. 找輪廓
    vector<vector<Point>> contours;
    vector<Vec4i> hierarchy;
    findContours(morphed, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

    // 6. 建立彩色輸出畫布
    Mat output_canvas;
    cvtColor(img, output_canvas, COLOR_GRAY2BGR);

    // 初始化 Tesseract
    tesseract::TessBaseAPI *ocr = new tesseract::TessBaseAPI();
    if (ocr->Init(NULL, "eng")) {
        cout << "Tesseract 初始化失敗" << endl;
        return -1;
    }
    // 設定白名單
    ocr->SetVariable("tessedit_char_whitelist", "0123456789+-.");

    cout << "--- 分割與合併結果展示 ---" << endl;
    int i = 0;
    for (size_t idx = 0; idx < contours.size(); idx++, i++) {
        Rect rect = boundingRect(contours[idx]);
        Mat roi = img(rect);

        // 反轉顏色
        Mat roi_inv;
        bitwise_not(roi, roi_inv);

        // 放大
        Mat roi_resized;
        resize(roi_inv, roi_resized, Size(), 2.0, 2.0, INTER_CUBIC);

        // 補邊框
        Mat roi_padded;
        copyMakeBorder(roi_resized, roi_padded, 20, 20, 20, 20, BORDER_CONSTANT, Scalar(255,255,255));

        // OCR 辨識
        ocr->SetImage(roi_padded.data, roi_padded.cols, roi_padded.rows, 1, roi_padded.step);
        string text = string(ocr->GetUTF8Text());
        // 去除空白與換行
        text.erase(remove(text.begin(), text.end(), '\n'), text.end());
        text.erase(remove(text.begin(), text.end(), '\r'), text.end());

        // 繪製結果
        rectangle(output_canvas, rect, Scalar(0,0,255), 2);
        putText(output_canvas, text, Point(rect.x, rect.y - 10),
                FONT_HERSHEY_SIMPLEX, 0.7, Scalar(0,0,255), 2);

        cout << "序號 #" << i << " [" << text << "]" << endl;
        string winName = "ROI " + to_string(i);
        imshow(winName, roi_padded);
    }

    cout << "\n整張圖的標記結果:" << endl;
    imshow("分割結果", output_canvas);

    waitKey(0);
    ocr->End();
    return 0;
}
```
![img](img/digits_identify.png)
