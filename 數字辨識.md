在影像辨識中，數字辨識是一個相對簡單的專案，因為變化少且流程單純，是一個很好學習的專案。

## 一、前處理
前處理通常包含以下步驟
1. 二值化
2. 降噪
3. 找邊
4. 找輪廓
3a. 形態學運算(膨脹/侵蝕)
找完後就可以去把每個數字分割出來
```c++
#include <opencv2/opencv.hpp>
#include <iostream>
using namespace cv;
using namespace std;

int main() {
    // 1. 讀取灰階圖片
    Mat img = imread("digits.png", IMREAD_GRAYSCALE);
    if (img.empty()) {
        cout << "無法讀取圖片" << endl;
        return -1;
    }
    imshow("原始影像", img);
    // 2. 降噪 (Gaussian Blur)
    Mat blurred;
    GaussianBlur(img, blurred, Size(5,5), 0);

    // 3. 使用 Canny 邊緣檢測
    Mat edges;
    Canny(blurred, edges, 50, 150);

    // 4. 使用閉運算 (Closing)
    Mat kernel = getStructuringElement(MORPH_RECT, Size(5,5));
    Mat morphed;
    morphologyEx(edges, morphed, MORPH_CLOSE, kernel, Point(-1,-1), 2);
    imshow("閉運算結果", morphed);

    // 5. 找輪廓
    vector<vector<Point>> contours;
    vector<Vec4i> hierarchy;
    findContours(morphed, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

    // 6. 繪製分割結果
    Mat output_canvas;
    cvtColor(img, output_canvas, COLOR_GRAY2BGR);

    cout << "--- 分割與合併結果展示 ---" << endl;
    for (size_t idx = 0, i = 0; idx < contours.size(); idx++, i++;) {
        Rect rect = boundingRect(contours[idx]);
        // 在原圖上畫出紅色框框
        rectangle(output_canvas, rect, Scalar(0,0,255), 2);
        // 寫上序號
        putText(output_canvas, "#" + to_string(i), Point(rect.x, rect.y - 5),
                FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0,0,255), 1);
        // 擷取 ROI
        Mat roi = img(rect);
        cout << "數字區塊 #" << (i+1) << ":" << endl;
        string winName = "ROI " + to_string(i+1);
        imshow(winName, roi);
    }

    cout << "\n整張圖的標記結果:" << endl;
    imshow("分割結果", output_canvas);

    waitKey(0); // 等待按鍵後關閉視窗
    return 0;
}
```
![img](img/digits.png)
![img](img/digits_mark.png)
