雖然 canny 能夠很好的找邊，但也有可能因為雜訊或是毛邊使得找出來的圖像與想要的有差，或者是原本應該要相連的區塊因為拍照而被斷開，所以除了做 blur 外還可以使用型態學來做前處理，實作過程也是利用摺積 convolution 來處理

## 一、侵蝕(Erosion)與膨脹
做侵蝕時如果與 kernel 重疊的部分其中一個為 0，那麼該塊的摺積就是 0，否則就保留。以 9* 9 的矩陣，3* 3 的 kernel 為例
```
原始矩陣：
[[  0   0   0   0   0   0   0   0   0]
 [  0 255 255 255 255 255 255 255   0]
 [  0 255 255 255 255 255 255 255   0]
 [  0 255 255 255 255 255 255 255   0]
 [  0 255 255 255 255 255 255 255   0]
 [  0 255 255 255 255 255 255 255   0]
 [  0 255 255 255 255 255 255 255   0]
 [  0 255 255 255 255 255 255 255   0]
 [  0   0   0   0   0   0   0   0   0]]

侵蝕後矩陣：
[[  0   0   0   0   0   0   0   0   0]
 [  0   0   0   0   0   0   0   0   0]
 [  0   0 255 255 255 255 255   0   0]
 [  0   0 255 255 255 255 255   0   0]
 [  0   0 255 255 255 255 255   0   0]
 [  0   0 255 255 255 255 255   0   0]
 [  0   0 255 255 255 255 255   0   0]
 [  0   0   0   0   0   0   0   0   0]
 [  0   0   0   0   0   0   0   0   0]]
```
```
Mat kernel = getStructuringElement(MORPH_RECT, Size(3,3));
Mat erosion;
erode(img, erosion, kernel);
//白色區域縮小，邊界被「吃掉」，常用來去除小白點或分離相連物件。
Mat dilation;
dilate(img, dilation, kernel);
//白色區域擴張，邊界向外擴展，常用來填補小黑洞或連接斷裂區域。
```
當 kernel 中心在(1, 1)時有包含到 0，所以出來的值即為 0，而到了 (2, 2) 時全都是 1，所以保留，而膨脹就是反過來，所以 code 可以加個 FLAG 來判斷是要侵時還膨脹。注意此操作是***不可逆***的，例如侵時多次多次後全都變為 0，此時再如何膨脹都無法變成 255。也可以看到這種操作會改變矩陣的值，所以需要在函數中另外宣告一個相同大小的矩陣存放摺積後的結果。
```C++
#include <iostream>
#include <vector>
using namespace std;

// mode = 0 → 侵蝕 (Erosion)
// mode = 1 → 膨脹 (Dilation)
vector<int> morph1D(const vector<int>& img, int rows, int cols, int kernelSize, int mode) {
    vector<int> result(rows * cols, 0);
    int k = kernelSize / 2;

    for (int i = k; i < rows - k; i++) {
        for (int j = k; j < cols - k; j++) {
            bool condition = (mode == 0); // 侵蝕: 全白才保留；膨脹: 有白就保留
            for (int ki = -k; ki <= k; ki++) {
                for (int kj = -k; kj <= k; kj++) {
                    int idx = (i + ki) * cols + (j + kj);
                    if (mode == 0) { // 侵蝕
                        if (img[idx] != 255) {
                            condition = false;
                            break;
                        }
                    } else { // 膨脹
                        if (img[idx] == 255) {
                            condition = true;
                            break;
                        }
                    }
                }
                if ((mode == 0 && !condition) || (mode == 1 && condition)) break;
            }
            result[i * cols + j] = condition ? 255 : 0;
        }
    }
    return result;
}
```
![img](img/Endorse_dialate.png)

## 二、形態學操作
這兩種操作即是 OPENCV 中型態學的基本運算，其他運算就是這兩個與其他操作組合而成。在 opencv 中是用 morphologyEx 函數搭配 flag 來決定要呼叫那些。
```C++
void cv::morphologyEx	(	InputArray 	src,
                        OutputArray 	dst,
                        int 	op,
                        InputArray 	kernel,
                        Point 	anchor = Point(-1,-1),
                        int 	iterations = 1,
                        int 	borderType = BORDER_CONSTANT,
                        const Scalar & 	borderValue = morphologyDefaultBorderValue() 
                        )		
```
其中第三個參數就是 FLAG
1. MORPH_OPEN
2. MORPH_CLOSE
3. MORPH_GRADIENT
4. MORPH_TOPHAT
5. MORPH_BLACKHAT

## 二、閉與開運算
利用侵蝕跟膨脹的不可逆來找出或保留特性
```
Mat opening;
morphologyEx(img, opening, MORPH_OPEN, kernel);

Mat closing;
morphologyEx(img, closing, MORPH_CLOSE, kernel);

Mat gradient;
morphologyEx(img, gradient, MORPH_GRADIENT, kernel);

Mat tophat;
morphologyEx(img, tophat, MORPH_TOPHAT, kernel);

Mat blackhat;
morphologyEx(img, blackhat, MORPH_BLACKHAT, kernel);
```
其效果可參考[教學網站](https://docs.opencv.org/3.4/Morphology_2_Tutorial_Theory_Closing.png)上的結果，在做實際專案時會利用邊緣檢測搭配形態學操作來做辨識。
